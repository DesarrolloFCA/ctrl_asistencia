<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use SIU\AraiJsonParser\Version\Constraints\MultiConstraint;
use SIU\AraiJsonParser\Version\VersionParser;
use SIU\AraiJsonParser\Version\Constraints\VersionConstraint;
use SIU\AraiJsonParser\Version\Constraints\EmptyConstraint;

class VersionParserTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @dataProvider successfulNormalizedVersions
     */
    public function testNormalizeSucceeds($input, $expected)
    {
        $parser = new VersionParser;
        $this->assertSame($expected, $parser->normalize($input));
    }

    public function successfulNormalizedVersions()
    {
        return array(
            'none'               => array('1.0.0',               '1.0.0.0'),
            'none/2'             => array('1.2.3.4',             '1.2.3.4'),
            'forces w.x.y.z/2'   => array('0',                   '0.0.0.0'),
            'strips leading v'   => array('v1.0.0',              '1.0.0.0'),
        );
    }

    /**
     * @dataProvider failingNormalizedVersions
     * @expectedException UnexpectedValueException
     */
    public function testNormalizeFails($input)
    {
        $parser = new VersionParser;
        $parser->normalize($input);
    }

    public function failingNormalizedVersions()
    {
        return array(
            'empty '            => array(''),
            'invalid chars'     => array('a'),
            'too many bits'     => array('1.0.0.0.0'),
        );
    }


    /**
     * @expectedException UnexpectedValueException
     * @expectedExceptionMessage Invalid operator "~>", you probably meant to use the "~" operator
     */
    public function testParseConstraintNudgesRubyDevsTowardsThePathOfRighteousness()
    {
        $parser = new VersionParser;
        $parser->parseConstraint('~>1.2');
    }

    /**
     * @dataProvider simpleConstraints
     */
    public function testParseConstraintSimple($input, $expected)
    {
        $parser = new VersionParser;
        $this->assertSame((string) $expected, (string) $parser->parseConstraint($input));
    }

    public function simpleConstraints()
    {
        return array(
            'match any'         => array('*',           new EmptyConstraint()),
            'match any/2'       => array('*.*',         new EmptyConstraint()),
            'match any/3'       => array('*.x.*',       new EmptyConstraint()),
            'match any/4'       => array('x.X.x.*',     new EmptyConstraint()),
            'not equal'         => array('<>1.0.0',     new VersionConstraint('<>', '1.0.0.0')),
            'not equal/2'       => array('!=1.0.0',     new VersionConstraint('!=', '1.0.0.0')),
            'greater than'      => array('>1.0.0',      new VersionConstraint('>', '1.0.0.0')),
            'lesser than'       => array('<1.2.3.4',    new VersionConstraint('<', '1.2.3.4')),
            'less/eq than'      => array('<=1.2.3',     new VersionConstraint('<=', '1.2.3.0')),
            'great/eq than'     => array('>=1.2.3',     new VersionConstraint('>=', '1.2.3.0')),
            'equals'            => array('=1.2.3',      new VersionConstraint('=', '1.2.3.0')),
            'double equals'     => array('==1.2.3',     new VersionConstraint('=', '1.2.3.0')),
            'no op means eq'    => array('1.2.3',       new VersionConstraint('=', '1.2.3.0')),
            'completes version' => array('=1.0',        new VersionConstraint('=', '1.0.0.0')),
            'accepts spaces'    => array('>= 1.2.3',    new VersionConstraint('>=', '1.2.3.0')),
            'accepts spaces/2'  => array('< 1.2.3',     new VersionConstraint('<', '1.2.3.0')),
            'accepts spaces/3'  => array('> 1.2.3',     new VersionConstraint('>', '1.2.3.0')),
        );
    }

    /**
     * @dataProvider wildcardConstraints
     */
    public function testParseConstraintWildcard($input, $min, $max)
    {
        $parser = new VersionParser;
        if ($min) {
            $expected = new MultiConstraint(array($min, $max));
        } else {
            $expected = $max;
        }

        $this->assertSame((string) $expected, (string) $parser->parseConstraint($input));
    }

    public function wildcardConstraints()
    {
        return array(
            array('2.*',     new VersionConstraint('>=', '2.0.0.0'), new VersionConstraint('<', '3.0.0.0')),
            array('20.*',    new VersionConstraint('>=', '20.0.0.0'), new VersionConstraint('<', '21.0.0.0')),
            array('2.0.*',   new VersionConstraint('>=', '2.0.0.0'), new VersionConstraint('<', '2.1.0.0')),
            array('2.2.x',   new VersionConstraint('>=', '2.2.0.0'), new VersionConstraint('<', '2.3.0.0')),
            array('2.10.X',  new VersionConstraint('>=', '2.10.0.0'), new VersionConstraint('<', '2.11.0.0')),
            array('2.1.3.*', new VersionConstraint('>=', '2.1.3.0'), new VersionConstraint('<', '2.1.4.0')),
            array('0.*',     null, new VersionConstraint('<', '1.0.0.0')),
        );
    }

    /**
     * @dataProvider tildeConstraints
     */
    public function testParseTildeWildcard($input, $min, $max)
    {
        $parser = new VersionParser;
        if ($min) {
            $expected = new MultiConstraint(array($min, $max));
        } else {
            $expected = $max;
        }

        $this->assertSame((string) $expected, (string) $parser->parseConstraint($input));
    }

    public function tildeConstraints()
    {
        return array(
            array('~1',       new VersionConstraint('>=', '1.0.0.0'), new VersionConstraint('<', '2.0.0.0')),
            array('~1.0',     new VersionConstraint('>=', '1.0.0.0'), new VersionConstraint('<', '2.0.0.0')),
            array('~1.0.0',   new VersionConstraint('>=', '1.0.0.0'), new VersionConstraint('<', '1.1.0.0')),
            array('~1.2',     new VersionConstraint('>=', '1.2.0.0'), new VersionConstraint('<', '2.0.0.0')),
            array('~1.2.3',   new VersionConstraint('>=', '1.2.3.0'), new VersionConstraint('<', '1.3.0.0')),
            array('~1.2.3.4', new VersionConstraint('>=', '1.2.3.4'), new VersionConstraint('<', '1.2.4.0')),
        );
    }

    /**
     * @dataProvider caretConstraints
     */
    public function testParseCaretWildcard($input, $min, $max)
    {
        $parser = new VersionParser;
        if ($min) {
            $expected = new MultiConstraint(array($min, $max));
        } else {
            $expected = $max;
        }

        $this->assertSame((string) $expected, (string) $parser->parseConstraint($input));
    }

    public function caretConstraints()
    {
        return array(
            array('^1',            new VersionConstraint('>=', '1.0.0.0'), new VersionConstraint('<', '2.0.0.0')),
            array('^0',            new VersionConstraint('>=', '0.0.0.0'), new VersionConstraint('<', '1.0.0.0')),
            array('^0.0',          new VersionConstraint('>=', '0.0.0.0'), new VersionConstraint('<', '0.1.0.0')),
            array('^1.2',          new VersionConstraint('>=', '1.2.0.0'), new VersionConstraint('<', '2.0.0.0')),
            array('^1.2.3.4',      new VersionConstraint('>=', '1.2.3.4'), new VersionConstraint('<', '2.0.0.0')),
            array('^1.2.3',        new VersionConstraint('>=', '1.2.3.0'), new VersionConstraint('<', '2.0.0.0')),
            array('^0.2.3',        new VersionConstraint('>=', '0.2.3.0'), new VersionConstraint('<', '0.3.0.0')),
            array('^0.2',          new VersionConstraint('>=', '0.2.0.0'), new VersionConstraint('<', '0.3.0.0')),
            array('^0.2.0',        new VersionConstraint('>=', '0.2.0.0'), new VersionConstraint('<', '0.3.0.0')),
            array('^0.0.3',        new VersionConstraint('>=', '0.0.3.0'), new VersionConstraint('<', '0.0.4.0')),
        );
    }

    /**
     * @dataProvider hyphenConstraints
     */
    public function testParseHyphen($input, $min, $max)
    {
        $parser = new VersionParser;
        if ($min) {
            $expected = new MultiConstraint(array($min, $max));
        } else {
            $expected = $max;
        }

        $this->assertSame((string) $expected, (string) $parser->parseConstraint($input));
    }

    public function hyphenConstraints()
    {
        return array(
            array('1 - 2',                new VersionConstraint('>=', '1.0.0.0'),   new VersionConstraint('<',  '3.0.0.0')),
            array('1.2.3 - 2.3.4.5',      new VersionConstraint('>=', '1.2.3.0'),   new VersionConstraint('<=', '2.3.4.5')),
            array('1 - 2.0',              new VersionConstraint('>=', '1.0.0.0'),   new VersionConstraint('<', '2.1.0.0')),
            array('1 - 2.1',              new VersionConstraint('>=', '1.0.0.0'),   new VersionConstraint('<', '2.2.0.0')),
            array('1.2 - 2.1.0',          new VersionConstraint('>=', '1.2.0.0'),   new VersionConstraint('<=', '2.1.0.0')),
            array('1.3 - 2.1.3',          new VersionConstraint('>=', '1.3.0.0'),   new VersionConstraint('<=', '2.1.3.0')),
        );
    }

    /**
     * @dataProvider multiConstraintProvider
     */
    public function testParseConstraintsMulti($constraint)
    {
        $parser = new VersionParser;
        $first = new VersionConstraint('>', '2.0.0.0');
        $second = new VersionConstraint('<=', '3.0.0.0');
        $multi = new MultiConstraint(array($first, $second));
        $this->assertSame((string) $multi, (string) $parser->parseConstraint($constraint));
    }

    public function multiConstraintProvider()
    {
        return array(
            array('>2.0,<=3.0'),
            array('>2.0, <=3.0'),
            array('>2.0 ,<=3.0'),
            array('>2.0 , <=3.0'),
            array('>2.0   , <=3.0'),
            array('> 2.0  ,  <=  3.0'),
            array('  > 2.0  ,  <=  3.0 '),
        );
    }


    /**
     * @dataProvider failingConstraints
     * @expectedException UnexpectedValueException
     */
    public function testParseConstraintsFails($input)
    {
        $parser = new VersionParser;
        $parser->parseConstraint($input);
    }

    public function failingConstraints()
    {
        return array(
            'empty '            => array(''),
            'invalid version'   => array('1.0.0-meh'),
            'operator abuse'    => array('>2.0,,<=3.0'),
            'operator abuse/2'  => array('>2.0 ,, <=3.0'),
        );
    }
}