<?php
namespace SIU\AraiJsonParser\Version;

use SIU\AraiJsonParser\Version\Constraints\ConstraintInterface;
use SIU\AraiJsonParser\Version\Constraints\EmptyConstraint;
use SIU\AraiJsonParser\Version\Constraints\MultiConstraint;
use SIU\AraiJsonParser\Version\Constraints\VersionConstraint;

class VersionParser
{
    /**
     * Normalizes a version string to be able to perform comparisons on it
     *
     * @param  string                    $version
     * @param  string                    $fullVersion optional complete version string to give more context
     * @throws \UnexpectedValueException
     * @return string
     */
    public function normalize($version, $fullVersion = null)
    {
        $version = trim($version);
        if (null === $fullVersion) {
            $fullVersion = $version;
        }

        $matched = false;
        // match classical versioning
        if (preg_match('{^v?(\d{1,3})(\.\d+)?(\.\d+)?(\.\d+)?$}i', $version, $matches)) {
            $version = $matches[1]
                .(!empty($matches[2]) ? $matches[2] : '.0')
                .(!empty($matches[3]) ? $matches[3] : '.0')
                .(!empty($matches[4]) ? $matches[4] : '.0');
            $matched = true;
        }

        if ($matched) {
            return $version;
        }

        throw new \UnexpectedValueException('Invalid version string "'.$version.'"');
    }

    /**
     * @param $constraint
     * @return ConstraintInterface
     */
    public function parseConstraint($constraint)
    {
        if (preg_match('{^[xX*](\.[xX*])*$}i', $constraint)) {
            return new EmptyConstraint;
        }

        $commaCount = substr_count($constraint, ',');
        if ($commaCount == 1) {
            $exploded = explode(',', $constraint);
            $res1 = $this->parseConstraint(trim($exploded[0]));
            $res2 = $this->parseConstraint(trim($exploded[1]));
            return new MultiConstraint([$res1, $res2]);
        } elseif ($commaCount > 1) {
            $message = 'Could not parse version constraint "'.$constraint.'"';
            throw new \UnexpectedValueException($message);
        }

        $versionRegex = '(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:\.(\d+))?';

        // match tilde constraints
        // like wildcard constraints, unsuffixed tilde constraints say that they must be greater than the previous
        // version, to ensure that unstable instances of the current version are allowed.
        // however, if a stability suffix is added to the constraint, then a >= match on the current version is
        // used instead
        if (preg_match('{^~>?'.$versionRegex.'$}i', $constraint, $matches)) {
            if (substr($constraint, 0, 2) === '~>') {
                throw new \UnexpectedValueException(
                    'Could not parse version constraint '.$constraint.': '.
                    'Invalid operator "~>", you probably meant to use the "~" operator'
                );
            }

            // Work out which position in the version we are operating at
            if (isset($matches[4]) && '' !== $matches[4]) {
                $position = 4;
            } elseif (isset($matches[3]) && '' !== $matches[3]) {
                $position = 3;
            } elseif (isset($matches[2]) && '' !== $matches[2]) {
                $position = 2;
            } else {
                $position = 1;
            }

            $lowVersion = $this->manipulateVersionString($matches, $position, 0);
            $lowerBound = new VersionConstraint('>=', $lowVersion, $constraint);

            // For upper bound, we increment the position of one more significance,
            // but highPosition = 0 would be illegal
            $highPosition = max(1, $position - 1);
            $highVersion = $this->manipulateVersionString($matches, $highPosition, 1);
            $upperBound = new VersionConstraint('<', $highVersion, $constraint);

            return new MultiConstraint([ $lowerBound, $upperBound ]);
        }

        // match caret constraints
        if (preg_match('{^\^'.$versionRegex.'($)}i', $constraint, $matches)) {
            // Work out which position in the version we are operating at
            if ('0' !== $matches[1] || '' === $matches[2]) {
                $position = 1;
            } elseif ('0' !== $matches[2] || '' === $matches[3]) {
                $position = 2;
            } else {
                $position = 3;
            }

            $lowVersion = $this->normalize(substr($constraint, 1));
            $lowerBound = new VersionConstraint('>=', $lowVersion, $constraint);

            // For upper bound, we increment the position of one more significance,
            // but highPosition = 0 would be illegal
            $highVersion = $this->manipulateVersionString($matches, $position, 1);
            $upperBound = new VersionConstraint('<', $highVersion, $constraint);

            return new MultiConstraint([ $lowerBound, $upperBound ]);
        }

        // match wildcard constraints
        if (preg_match('{^(\d+)(?:\.(\d+))?(?:\.(\d+))?\.[xX*]$}', $constraint, $matches)) {
            if (isset($matches[3]) && '' !== $matches[3]) {
                $position = 3;
            } elseif (isset($matches[2]) && '' !== $matches[2]) {
                $position = 2;
            } else {
                $position = 1;
            }

            $lowVersion = $this->manipulateVersionString($matches, $position);
            $highVersion = $this->manipulateVersionString($matches, $position, 1);

            if ($lowVersion === "0.0.0.0") {
                return new VersionConstraint('<', $highVersion, $constraint);
            }

            return new MultiConstraint(array(
                new VersionConstraint('>=', $lowVersion, $constraint),
                new VersionConstraint('<', $highVersion, $constraint),
            ));
        }

        // match hyphen constraints
        if (preg_match('{^(?P<from>'.$versionRegex.') +- +(?P<to>'.$versionRegex.')($)}i', $constraint, $matches)) {
            $lowVersion = $this->normalize($matches['from']);
            $lowerBound = new VersionConstraint('>=', $lowVersion, $constraint);

            $empty = function ($x) {
                return ($x === 0 || $x === "0") ? false : empty($x);
            };

            if ((!$empty($matches[8]) && !$empty($matches[9]))) {
                $highVersion = $this->normalize($matches['to']);
                $upperBound = new VersionConstraint('<=', $highVersion);
            } else {
                $highMatch = array('', $matches[7], $matches[8], $matches[9], $matches[10]);
                $highVersion = $this->manipulateVersionString($highMatch, $empty($matches[8]) ? 1 : 2, 1);
                $upperBound = new VersionConstraint('<', $highVersion, $constraint);
            }

            return new MultiConstraint(array(
                $lowerBound,
                $upperBound
            ));
        }

        // match operators constraints
        if (preg_match('{^(<>|!=|>=?|<=?|==?)?\s*(.*)}', $constraint, $matches)) {
            try {
                $version = $this->normalize($matches[2]);
                return new VersionConstraint($matches[1] ?: '=', $version, $constraint);
            } catch (\Exception $e) {
            }
        }

        $message = 'Could not parse version constraint "'.$constraint.'"';
        if (isset($e)) {
            $message .= ': '. $e->getMessage();
        }

        throw new \UnexpectedValueException($message);
    }

    /**
     * Increment, decrement, or simply pad a version number.
     *
     * Support function for {@link parseConstraint()}
     *
     * @param  array  $matches   Array with version parts in array indexes 1,2,3,4
     * @param  int    $position  1,2,3,4 - which segment of the version to decrement
     * @param  int    $increment
     * @param  string $pad       The string to pad version parts after $position
     * @return string The new version
     */
    private function manipulateVersionString($matches, $position, $increment = 0, $pad = '0')
    {
        for ($i = 4; $i > 0; $i--) {
            if ($i > $position) {
                $matches[$i] = $pad;
            } elseif ($i == $position && $increment) {
                $matches[$i] += $increment;
                // If $matches[$i] was 0, carry the decrement
                if ($matches[$i] < 0) {
                    $matches[$i] = $pad;
                    $position--;

                    // Return null on a carry overflow
                    if ($i == 1) {
                        return;
                    }
                }
            }
        }

        return $matches[1] . '.' . $matches[2] . '.' . $matches[3] . '.' . $matches[4];
    }

    /**
     * Parses a name/version pairs and returns an array of pairs + the
     *
     * @param  array   $pairs a set of package/version pairs separated by ":", "=" or " "
     * @return array[] array of arrays containing a name and (if provided) a version
     */
//    public function parseNameVersionPairs(array $pairs)
//    {
//        $pairs = array_values($pairs);
//        $result = array();
//
//        for ($i = 0, $count = count($pairs); $i < $count; $i++) {
//            $pair = preg_replace('{^([^=: ]+)[=: ](.*)$}', '$1 $2', trim($pairs[$i]));
//            if (false === strpos($pair, ' ') && isset($pairs[$i+1]) && false === strpos($pairs[$i+1], '/')) {
//                $pair .= ' '.$pairs[$i+1];
//                $i++;
//            }
//
//            if (strpos($pair, ' ')) {
//                list($name, $version) = explode(" ", $pair, 2);
//                $result[] = array('name' => $name, 'version' => $version);
//            } else {
//                $result[] = array('name' => $pair);
//            }
//        }
//
//        return $result;
//    }
}